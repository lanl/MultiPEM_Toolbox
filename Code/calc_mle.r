########################################################################
#                                                                      #
# This file contains code for maximizing the log-likelihood of the     #
# calibration parameters, with an option to include errors-in-         #
# variables for calibration data yields. New event data can also be    #
# optionally incorporated, allowing for joint inference of new event   #
# and calibration parameters based on calibration and new event data.  #
#                                                                      #
# Â© 2023. Triad National Security, LLC. All rights reserved.           #
# This program was produced under U.S. Government contract             #
# 89233218CNA000001 for Los Alamos National Laboratory (LANL), which   #
# is operated by Triad National Security, LLC for the U.S. Department  #
# of Energy/National Nuclear Security Administration. All rights in    #
# the program are reserved by Triad National Security, LLC, and the    #
# U.S. Department of Energy/National Nuclear Security Administration.  #
# The Government is granted for itself and others acting on its behalf #
# a nonexclusive, paid-up, irrevocable worldwide license in this       #
# material to reproduce, prepare derivative works, distribute copies   #
# to the public, perform publicly and display publicly, and to permit  #
# others to do so.                                                     #
#                                                                      #
########################################################################

calc_mle = function(p_cal,gdir,adir,f,nst=10,ncor=1,ci_lev=0.95,
                    igrad=TRUE,bfgs=TRUE,igrck=TRUE,t_cal=NULL,g=NULL,
                    iresp=NULL,fp_fm=NULL,fopt_in=NULL,Xst=NULL,
                    tst=NULL,cst=NULL,fopt_out=NULL,phen=NULL,
                    pl="multicore")
{
  #
  # FUNCTION INPUTS
  #

  # p_cal: environment storing all objects needed in characterization
  #        calculations
  # gdir: directory for general subroutines
  # adir: directory for application subroutines
  # f: names of forward models for each response by phenomenology
  # nst: number of starting values for MLE optimization
  # ncor: number of cores for MLE optimization
  # ci_lev: confidence interval levels for calibration and new event
  #         parameter inference
  # igrad: forward model gradients provided (TRUE/FALSE)
  # bfgs: MLE optimization uses BFGS methods (TRUE/FALSE)
  # igrck: Likelihood function gradient check (TRUE/FALSE)
  # t_cal: object used if bounds supplied to MLE optimization
  # g: names of forward model gradients for each response by
  #    phenomenology
  # iresp: flags for modified calculation by response in a common
  #        forward model for each relevant phenomenology
  # fp_fm: fixed inputs required by forward models
  # fopt_in: location of input R data files with starting values for
  #          MLE optimization
  # Xst: matrix of starting values for MLE optimization if not
  #      generated by this function
  # tst: vector of starting values for new event parameters in
  #      MLE optimization
  # cst: vector of starting values for calibration inference parameters
  #      in MLE optimization
  # fopt_out: location to write output R data file with results of
  #           MLE optimization
  # phen: phenomenology number and type (if needed for postprocessing)
  # pl: strategy for running parallel jobs (see help for plan()
  #     function in future package)

  #
  # END FUNCTION INPUTS
  #

  #
  # SOURCE SUPPORTING R FUNCTIONS
  #

  # Global
  # log-likelihood functions
  source(paste(gdir,"/log_likelihood_cal.r",sep=""),local=TRUE)
  source(paste(gdir,"/log_likelihood_eiv.r",sep=""),local=TRUE)
  source(paste(gdir,"/log_likelihood_full.r",sep=""),local=TRUE)
  source(paste(gdir,"/make_opt.r",sep=""),local=TRUE)
  source(paste(gdir,"/ess_cov.r",sep=""),local=TRUE)
  if( igrad ){
    # gradient of log-likelihood functions
    source(paste(gdir,"/glog_likelihood_cal.r",sep=""),local=TRUE)
    source(paste(gdir,"/glog_likelihood_eiv.r",sep=""),local=TRUE)
    source(paste(gdir,"/glog_likelihood_full.r",sep=""),local=TRUE)
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){  
      # R function to calculate information matrix for new event
      # parameters
      source(paste(gdir,"/info_likelihood_0.r",sep=""),local=TRUE)
    } else {
      if( p_cal$ncalp > 0 ){
        # R function to calculate information matrix for calibration
        # inference parameters
        source(paste(gdir,"/info_likelihood_cal.r",sep=""),local=TRUE)
      }
    }
  } else {
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
      # R function to calculate observed information matrix
      # for new event parameters
      source(paste(gdir,"/observed_information_0.r",sep=""),local=TRUE)
    } else {
      if( p_cal$ncalp > 0 ){
        # R function to calculate observed information matrix
        # for calibration inference parameters
        source(paste(gdir,"/observed_information_cal.r",sep=""),
               local=TRUE)
      }
    }
  }
  # error catching
  source(paste(gdir,"/tryCatch.W.E.r",sep=""),local=TRUE)

  # Application
  # forward models
  source(paste(adir,"/forward.r",sep=""),local=TRUE)
  for( hh in 1:p_cal$H ){
    ufn = unique(f[[hh]])
    lfn = length(ufn)
    for( qq in 1:lfn ){
      eval(parse(text=paste("p_cal$ffm$",ufn[qq]," = ",ufn[qq],sep="")))
    }
  }
  if( igrad ){
    # gradient of forward models
    source(paste(adir,"/jacobian.r",sep=""),local=TRUE)
    if( is.null(g) ){
      stop("Gradient function names must be provided.")
    }
    for( hh in 1:p_cal$H ){
      ugn = unique(g[[hh]])
      lgn = length(ugn)
      for( qq in 1:lgn ){
        eval(parse(text=paste("p_cal$gfm$",ugn[qq]," = ",ugn[qq],
                              sep="")))
      }
    }
  }
  # print summary statistics
  source(paste(adir,"/print_sumstats.r",sep=""),local=TRUE)

  #
  # END SOURCE SUPPORTING R FUNCTIONS
  #

  #
  # USER SPECIFIED FIELDS
  #

  # Names of forward models and gradients
  for( hh in 1:p_cal$H ){
    p_cal$h[[hh]]$f = f[[hh]]
    if( igrad ){
      if( is.null(g) ){
        stop("Gradient function names must be provided.")
      }
      p_cal$h[[hh]]$g = g[[hh]]
    }
  }

  # Flags for modified calculation by response
  if( !is.null(iresp) ){
    for( hh in 1:p_cal$H ){
      if( !is.null(iresp[[hh]]) ){
        p_cal$h[[hh]]$iResponse = iresp[[hh]]
      }
    }
  }

  # Fixed quantities required by forward models
  if( !is.null(fp_fm) ){
    for( hh in 1:p_cal$H ){
      if( !is.null(fp_fm[[hh]]) ){
        p_cal$h[[hh]]$llpars = fp_fm[[hh]]
      }
    }
  }

  #
  # END USER SPECIFIED FIELDS
  #

  #
  # ADDITIONAL QUANTITIES USED IN CALCULATIONS
  #

  # statistical model functions
  if( !igrad ){ gll_cal = NULL; gll_full = NULL; }
  p_cal$ll_cal = ll_cal; p_cal$gll_cal = gll_cal;
  p_cal$ll_full = ll_full; p_cal$gll_full = gll_full;
  if( exists("eiv",where=p_cal,inherits=FALSE) && p_cal$eiv ){
    if( !igrad ){ gll_eiv = NULL }
    p_cal$ll_eiv = ll_eiv; p_cal$gll_eiv = gll_eiv;
  }
  if( !igrad ){
    if( p_cal$ncalp > 0 ){ p_cal$obs_info_cal = obs_info_cal }
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ) {
      p_cal$obs_info_0 = obs_info_0
    }
  }
  # support functions
  p_cal$tryCatch.W.E = tryCatch.W.E 
  p_cal$print_ss = print_ss

  # Specifications for MLE
  # Starting value for optimization
  if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
    tlb = p_cal$theta0_bounds[,1]
    tub = p_cal$theta0_bounds[,2]
  }
  if( is.null(Xst) ){
    if( !is.null(fopt_in) ){
      opt = vector("list",length(fopt_in))
      for( qq in 1:length(fopt_in) ){
        opt[[qq]] = readRDS(fopt_in[qq])
      }
      betaHat = tbetaHat = vc1Hat = vc2Hat = epsHat = NULL
      for( qq in 1:length(fopt_in) ){
        onames = names(opt[[qq]])
        if( "beta" %in% onames ){ betaHat = c(betaHat,opt[[qq]]$beta) }
        if( "tbeta" %in% onames ){
          tbetaHat = c(tbetaHat,opt[[qq]]$tbeta)
        }
        if( "vc_1" %in% onames ){ vc1Hat = c(vc1Hat,opt[[qq]]$vc_1) }
        if( "vc_2" %in% onames ){ vc2Hat = c(vc2Hat,opt[[qq]]$vc_2) }
        epsHat = c(epsHat,opt[[qq]]$eps)
      }
    }
    Xst = NULL
    for( ii in 1:nst ){
      nxst = 0
      if( ii > 1 ){
        xst = NULL
        if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
          xst = runif(p_cal$ntheta0, min=-2, max=2)
          itheta0_bounds = vector("list",3)
          if( exists("itheta0_bounds",where=p_cal,inherits=FALSE) ){
            itheta0_bounds=p_cal$itheta0_bounds
          } else if( !is.null(t_cal) ){
            itheta0_bounds=t_cal$itheta0_bounds
          }   
          if( length(itheta0_bounds[[1]]) > 0 ){
            for( jj in itheta0_bounds[[1]] ){
              xst[jj] = runif(1, min=tlb[jj], max=tlb[jj]+4)
            }
          }
          if( length(itheta0_bounds[[2]]) > 0 ){
            for( jj in itheta0_bounds[[2]] ){
              xst[jj] = runif(1, min=tub[jj]-4,max=tub[jj])
            }
          }
          if( length(itheta0_bounds[[3]]) > 0 ){
            for( jj in itheta0_bounds[[3]] ){
              xst[jj] = runif(1, min=tlb[jj],max=tub[jj])
            }
          }
          nxst = nxst + p_cal$ntheta0
        }
        if( p_cal$ncalp > 0 ){ nxst = nxst + p_cal$ncalp }
        xst = c(xst, runif(p_cal$nmpars-p_cal$ntheta0, min=-2, max=2))
      } else {
        xst = numeric(p_cal$nmpars)
        if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
          if( !is.null(tst) ){ xst[1:p_cal$ntheta0] = tst }
          nxst = nxst + p_cal$ntheta0
        }
        if( p_cal$ncalp > 0 ){
          if( !is.null(cst) ){ xst[nxst + 1:p_cal$ncalp] = cst }
          nxst = nxst + p_cal$ncalp
        }
      }
      if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev &&
          !p_cal$opt_B ){
        if( exists("itheta0_bounds",where=p_cal,inherits=FALSE) ){
          xst[1:p_cal$ntheta0] =
            p_cal$inv_transform(xst[1:p_cal$ntheta0],pc=p_cal)
        }
        if( exists("itransform",where=p_cal,inherits=FALSE) ){
          if( p_cal$itransform ){
            xst[1:p_cal$ntheta0] = p_cal$inv_tau(xst[1:p_cal$ntheta0],
                                                 pc=p_cal)
          }
        }
      }
      if( exists("eiv",where=p_cal,inherits=FALSE) && p_cal$eiv ){
        xst[nxst + 1:p_cal$nsource] = p_cal$eiv_w
      }
      if( !is.null(fopt_in) && ii == 1 ){
        nxst = 0
        if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
          if( ("theta0" %in% names(opt[[1]])) && is.null(tst) ){
            xst[1:p_cal$ntheta0] = opt[[1]]$theta0
          }
          nxst = nxst + p_cal$ntheta0
        }
        if( p_cal$ncalp > 0 ){
          if( ("calp" %in% names(opt[[1]])) && is.null(cst) ){
            xst[nxst + 1:p_cal$ncalp] = opt[[1]]$calp
          }
          nxst = nxst + p_cal$ncalp
        }
        if( nxst > 0 || p_cal$nsource > 0 ){
          xst[-(1:(nxst+p_cal$nsource))] =
          c(betaHat,tbetaHat,vc1Hat,vc2Hat,epsHat)
        } else { xst = c(betaHat,tbetaHat,vc1Hat,vc2Hat,epsHat) }
      }
      Xst = rbind(Xst, xst)
    }
  } else { Xst = Xst }
  p_cal$Xst = Xst

  #
  # END ADDITIONAL QUANTITIES USED IN CALCULATIONS
  #

  #
  # MAXIMUM LIKELIHOOD CALCULATION
  #

  # Maximize log likelihood to find MLE
  if( p_cal$opt_B ){
    lb_optim = rep(-Inf, p_cal$nmpars)
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
      lb_optim[1:p_cal$ntheta0] = tlb
    }
    p_cal$lb_optim = lb_optim
    ub_optim = rep(Inf, p_cal$nmpars)
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
      ub_optim[1:p_cal$ntheta0] = tub
    }
    p_cal$ub_optim = ub_optim
  }
  for( ii in 1:nst ){
    xst = Xst[ii,]
    while( is.infinite(ll_full(xst, pc=p_cal)) ){
      xst = calc_xst(p_cal,t_cal)
    }
    Xst[ii,] = xst
  }
  p_cal$calc_xst = calc_xst
  # parallel optimization using R package "future"
  require(doFuture)
  if( ncor == 1 ){ pl = "sequential"; plan(pl);
  } else {
    if( ncor > nst ){ ncor = nst }
    if( pl != "sequential" ){ plan(pl,workers=ncor)
    } else { plan(pl) }
  }
  cmax = -Inf
  ptm = proc.time()
  fCatch = foreach( qq = 1:nst ) %dofuture% {
             ll_opt(Xst[qq,],bfgs,p_cal,t_cal)
           } %seed% TRUE
  plan(sequential)
  print("Run time:")
  print(proc.time() - ptm)
  cat("\n")
  Mll = NULL
  for( qq in 1:nst ){
    if( is(fCatch[[qq]]$value,"list") ){
      Mle = fCatch[[qq]]$value
      Mll = c(Mll,Mle$value)
    } else { Mll = c(Mll,-Inf) }
  }
  imax = which( Mll == max(Mll) ); imax = imax[1];
  if( Mll[imax] > cmax ){
    cmax = Mll[imax]
    mle = fCatch[[imax]]$value
  }
  qq = 0; irel_tol = 0;
  while( qq <= 5 ){
    cmax = mle$value
    if( bfgs ){
      if( p_cal$opt_B ){
        mle = optim(mle$par, fn=ll_full, gr=gll_full, pc=p_cal,
                    method="L-BFGS-B",
                    lower=lb_optim, upper=ub_optim,
                    control=list(fnscale = -1,maxit=1000))
      } else {
        mle = optim(mle$par, fn=ll_full, gr=gll_full, pc=p_cal,
                    method="BFGS",
                    control=list(fnscale = -1,maxit=1000))
      }
    } else {
      if( p_cal$opt_B ){
        mle = optim(mle$par, fn=ll_full, pc=p_cal,
                    lower=lb_optim, upper=ub_optim,
                    control=list(fnscale = -1,maxit=10000))
      } else {
        mle = optim(mle$par, fn=ll_full, pc=p_cal,
                    control=list(fnscale = -1,maxit=10000))
      }
    }
    rel_tol = abs(mle$value - cmax)/abs(cmax)
    if( rel_tol <= 1.e-8 ){ irel_tol = irel_tol+1
    } else { qq = qq+1 }
    if( irel_tol == 2 ){ break }
  }
  # compute Hessian to obtain observed Fisher information matrix
  # in applications where gradients are not available
  if( !igrad ){
    if( p_cal$opt_B ){
      mle = optim(mle$par, fn=ll_full, pc=p_cal,
                  lower=lb_optim, upper=ub_optim,
                  control=list(fnscale = -1,maxit=10000),
                  hessian=TRUE)
    } else {
      mle = optim(mle$par, fn=ll_full, pc=p_cal,
                  control=list(fnscale = -1,maxit=10000),
                  hessian=TRUE)
    }
  }

  # Print convergence status of log-likelihood optimization
  print("MLE CONVERGENCE STATUS")
  cat("\n")
  print(mle$convergence)
  print(irel_tol)

  # Additional information if convergence obtained
  if( mle$convergence == 0 ){
    p_cal$mle = unname(mle$par)
    opt_mle = make_opt(mle$par, p_cal)
    if( !is.null(fopt_out) ){ saveRDS(opt_mle, file=fopt_out) }
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
      # Calculate asymptotic covariance matrix
      # for new event inference parameters
      if( igrad ){
        p_cal$Sigma_mle_0 = info_ll_0(opt_mle, p_cal)
      } else {
        if( p_cal$opt_B ){
          if( is.null(t_cal) ){
            stop(paste("List t_cal must be provided for bounded",
                       " optimization.",sep=""))
          }
          p_cal$Sigma_mle_0 = obs_info_0(p_cal, mle, imle=TRUE,
                                         t_cal=t_cal)
        } else {
          p_cal$Sigma_mle_0 = obs_info_0(p_cal, mle, imle=TRUE)
        }
      }
    } else {
      # Calculate asymptotic covariance matrix
      # for calibration inference parameters 
      if( p_cal$ncalp > 0 ){ 
        if( igrad ){ 
          p_cal$Sigma_mle_cal = info_ll_cal(opt_mle, p_cal)
        } else {
          p_cal$Sigma_mle_cal = obs_info_cal(p_cal, mle, imle=TRUE)
        }
      }
    }
    # Print MLE
    print("MAXIMUM LIKELIHOOD SUMMARY")
    cat("\n")
    if( !is.null(phen) ){
      # Indicate phenomenology
      for( qq in 1:nrow(phen) ){
        p_cal$h[[as.numeric(phen[qq,1])]]$Phen = phen[qq,2]
      }
    }

    # Indicator of prior distribution parameters
    p_cal$iPrior = FALSE
    if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
      p_cal = print_ss(mle$par, p_cal, ci=ci_lev)
    } else {
      if( p_cal$ncalp > 0 ){ p_cal = print_ss(mle$par,p_cal,ci=ci_lev)
      } else { p_cal = print_ss(mle$par, p_cal) }
    }

    # Model summaries
    ll_max = ll_full(mle$par, p_cal)
    AIC = -2*ll_max+2*p_cal$nmpars
    ess = ess_cov(opt_mle, p_cal)
    BIC = -2*ll_max+p_cal$nmpars*log(ess)

    print(paste("AIC = ",round(AIC,2),sep=""))
    cat("\n")
    print(paste("BIC = ",round(BIC,2),sep=""))
    cat("\n")
  }

  #
  # END MAXIMUM LIKELIHOOD CALCULATION
  #

  #
  # CHECK LOG-LIKELIHOOD GRADIENT CALCULATIONS
  #

  if( igrck && igrad ){
    # numerical differentiation package
    require(numDeriv)
    print("CHECK LOG-LIKELIHOOD GRADIENTS")
    cat("\n")
    xnom = unname(mle$par)
    Catch = p_cal$tryCatch.W.E(gll_full(xnom,p_cal))
    if( is(Catch$value,"numeric") ){ gll_full_nom = Catch$value
    } else {
      gll_full_nom = NaN
      print("Error computing analytic gradient at MLE.")
    }
    Catch = p_cal$tryCatch.W.E(grad(ll_full, xnom,
                                    method.args=list(r=6),pc=p_cal))
    if( is(Catch$value,"numeric") ){ gll_full_nom_num = Catch$value
    } else {
      gll_full_nom_num = NaN
      print("Error computing numerical gradient at MLE.")
    }
    diff <- gll_full_nom - gll_full_nom_num
    print("Analytic gradient")
    print(gll_full_nom)
    print("Numerical gradient")
    print(gll_full_nom_num)
    print("Difference")
    print(c(min(diff),max(diff)))
    cat("\n")

    nsamp = 5
    qq = 1
    while( qq <= nsamp ){
      xx = xnom + rnorm(p_cal$nmpars,mean=0,sd=0.1)
      Catch = p_cal$tryCatch.W.E(gll_full(xx,p_cal))
      if( is(Catch$value,"numeric") ){ gll_full_xx = Catch$value
      } else { next }
      Catch = p_cal$tryCatch.W.E(grad(ll_full, xx,
                                      method.args=list(r=6),pc=p_cal))
      if( is(Catch$value,"numeric") ){
        qq = qq+1
        gll_full_xx_num = Catch$value
      } else { next }
      diff <- gll_full_xx - gll_full_xx_num
      print("Analytic gradient")
      print(gll_full_xx)
      print("Numerical gradient")
      print(gll_full_xx_num)
      print("Difference")
      print(c(min(diff),max(diff)))
      cat("\n")
    }
  }

  #
  # END CHECK LOG-LIKELIHOOD GRADIENT CALCULATIONS
  #

  return(p_cal)
}

calc_xst = function(p_cal,t_cal)
{
  nxst = 0
  xst = NULL
  if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev ){
    xst = runif(p_cal$ntheta0, min=-2, max=2)
    tlb = p_cal$theta0_bounds[,1]
    tub = p_cal$theta0_bounds[,2]
    itheta0_bounds = vector("list",3)
    if( exists("itheta0_bounds",where=p_cal,inherits=FALSE) ){
      itheta0_bounds=p_cal$itheta0_bounds
    } else if( !is.null(t_cal) ){
      itheta0_bounds=t_cal$itheta0_bounds
    }
    if( length(itheta0_bounds[[1]]) > 0 ){
      for( jj in itheta0_bounds[[1]] ){
        xst[jj] = runif(1, min=tlb[jj],max=tlb[jj]+4)
      }
    }
    if( length(itheta0_bounds[[2]]) > 0 ){
      for( jj in itheta0_bounds[[2]] ){
        xst[jj] = runif(1, min=tub[jj]-4,max=tub[jj])
      }
    }
    if( length(itheta0_bounds[[3]]) > 0 ){
      for( jj in itheta0_bounds[[3]] ){
        xst[jj] = runif(1, min=tlb[jj],max=tub[jj])
      }
    }
    nxst = nxst + p_cal$ntheta0
  }
  xst = c(xst, runif(p_cal$nmpars-p_cal$ntheta0, min=-2, max=2))
  if( exists("nev",where=p_cal,inherits=FALSE) && p_cal$nev &&
      !p_cal$opt_B ){
    if( exists("itheta0_bounds",where=p_cal,inherits=FALSE) ){
      xst[1:p_cal$ntheta0] =
        p_cal$inv_transform(xst[1:p_cal$ntheta0],pc=p_cal)
    }
    if( exists("itransform",where=p_cal,inherits=FALSE) ){
      if( p_cal$itransform ){
        xst[1:p_cal$ntheta0] = p_cal$inv_tau(xst[1:p_cal$ntheta0],
                                             pc=p_cal)
      }
    }
  }
  if( p_cal$ncalp > 0 ){ nxst = nxst + p_cal$ncalp }
  if( exists("eiv",where=p_cal,inherits=FALSE) && p_cal$eiv ){
    xst[nxst + 1:p_cal$nsource] = p_cal$eiv_w
  }
  return(xst)
}

ll_opt = function(xst,bfgs,pc,tc)
{
  maxiter = 5
  ii = 1
  while( ii <= maxiter ){
    if( bfgs ){
      if( pc$opt_B ){
        Catch = pc$tryCatch.W.E(optim(xst, fn=pc$ll_full,
                gr=pc$gll_full, pc=pc, method="L-BFGS-B",
                lower=pc$lb_optim, upper=pc$ub_optim,
                control=list(fnscale = -1,maxit=1000)))
      } else {
        Catch = pc$tryCatch.W.E(optim(xst, fn=pc$ll_full,
                gr=pc$gll_full, pc=pc, method="BFGS",
                control=list(fnscale = -1,maxit=1000)))
      }
    } else {
      if( pc$opt_B ){
        Catch = pc$tryCatch.W.E(optim(xst, fn=pc$ll_full,
                pc=pc, lower=pc$lb_optim, upper=pc$ub_optim,
                control=list(fnscale = -1,maxit=10000)))
      } else {
        Catch = pc$tryCatch.W.E(optim(xst, fn=pc$ll_full,
                pc=pc, control=list(fnscale = -1,maxit=10000)))
      }
    }
    if( is(Catch$value,"list") ){
      return(Catch)
    } else {
      xst = pc$calc_xst(pc,tc)
      while( is.infinite(pc$ll_full(xst, pc=pc)) ){
        xst = pc$calc_xst(pc,tc)
      }
      ii = ii+1
      if( ii > maxiter ){ return(Catch) } else { next }
    }
  }
}
